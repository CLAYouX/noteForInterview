[TOC]

## 继承与面向对象设计

### 绝不重新定义继承来的非虚函数

- 对象的静态绑定类型是其在程序中 **被声明时** 所采用的类型；对象的动态绑定类型则是指 **目前所指对象的类型**；

- 类的非虚成员函数的调用是 **编译时静态绑定**；虚成员函数则是 **运行时动态绑定**；

### 绝不重新定义继承而来的缺省值

- 虚函数是动态绑定，而缺省参数却是 **静态绑定**；
- C++坚持这种方式是考虑到 **运行期效率**；如果缺省参数值是动态绑定的，编译器漆就必须有某种方法在运行期为虚函数决定适当的参数缺省值，这比目前的编译期决定机制更慢更复杂；

### 明智而审慎地使用 private 继承

- 如果类之间的继承关系是 **私有的 private**，编译器不会自动将一个派生类对象转换为一个基类对象；
- 由基类私有继承来的所有成员，在派生类中都会变成私有属性；
- 私有继承意味着 **根据某物实现出**，其纯粹只是一种实现技术；
- 尽可能使用复合，必要时才使用私有继承；
- 私有继承主要用于 **当派生类需要访问基类的保护成员，或需要重新定义继承来的一个或多个虚函数**；
- 有一种激进情况涉及空间最优化，也会促使使用私有继承：
  - C++ 裁定凡是 **独立非附属的对象都必须具有非零大小**，即空类也会有大小；
  - C++ 会默默安插一个 `char` 到空对象内；
  - 上述约束不适用于派生类对象内的基类对象成分，因为它们并不是独立非附属；
  - 如果私有继承一个空类，空类就不会有大小，这叫做 **空白基类最优化 EBO**.

### 明智而审慎地使用多重继承

- 多重继承比单一继承复杂，可能导致新的歧义性，以及对 **虚继承** 的需求；
- 虚继承会增加大小、速度、初始化（赋值）复杂度等成本。如果虚基类不带任何数据，将是最具有实用价值的情况；
- 多重继承的正当用途：公有继承某个接口类，私有继承某个协助实现的类。