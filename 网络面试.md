## HTTP相关

### HTTP基本概念

- HTTP 是超文本传输协议，也就是HyperText Transfer Protocol

  - HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。
- HTTP 常见的状态码
<img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210508160807424.png" alt="image-20210508160807424" style="zoom:67%;" />
- HTTP 常见字段
  - Host 字段：指定服务器的域名
  - Content-Length 字段：服务器在返回数据时表明本次回应的数据长度
  - Connection 字段：用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用
  - Content-Type 字段：段用于服务器回应时，告诉客户端，本次数据是什么格式
  - Content-Encoding 字段：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式



### GET与POST

- GET方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等
- POST方法向 URI 指定的资源提交数据，数据就放在报文的 body 里
- 安全和幂等
  - **安全**：请求方法不会「破坏」服务器上的资源
  - **幂等**：多次执行相同的操作，结果都是「相同」的
- **GET 方法就是安全且幂等的**：「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的
- **POST方法是不安全且不幂等的**：因为是「新增或提交数据」的操作，会修改服务器上的资源，且多次提交数据就会创建多个资源



### HTTP的特性

- **HTTP 的优点**：

  - 简单
  - 灵活和易于扩展
  - 应用广泛和跨平台

- **HTTP 的缺点**：无状态、明文传输、不安全

  - 无状态
    - 无状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。
    - 无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦
    - 通过在请求和响应报文中写入 **Cookie 信息**来控制客户端的状态
  - 明文传输
    - HTTP 的所有信息可直接查看
  - 不安全
    - 通信使用明文（不加密），内容可能会被窃听
    - 不验证通信方的身份，因此有可能遭遇伪装
    - 无法证明报文的完整性，所以有可能已遭篡改
    - HTTP 的安全问题，可以用 **HTTPS** 的方式解决，也就是通过引入 **SSL/TLS** 层，使得在安全上达到了极致。

- **HTTP的性能**

  - HTTP 协议是基于 TCP/IP，并且使用了**「请求 - 应答」**的通信模式，所以性能的关键就在这两点里
  - 长连接
    - 减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载
    - 只要任意一端没有明确提出断开连接，则保持 TCP 连接状态

  - 管道网络传输（pipeline）
    - 在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间**
    - 管道机制则是允许浏览器同时发出 多个请求，但是服务器还是按照顺序，先回应先到的请求，完成后再回应后到的请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为**「队头堵塞」**
  - 队头阻塞
    - <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210508163007332-1620462676708.png" alt="image-20210508163007332" style="zoom:67%;" />
    - 当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」



### HTTP与HTTPS

- HTTP 与 HTTPS 的区别
  - HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输
  - HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP三次握手之后，还需进行 **SSL/TLS** 的握手过程，才可进入加密报文传输
  - HTTP 的端口号是 80，HTTPS 的端口号是 443
  - HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的
- HTTPS 解决了 HTTP 的哪些问题
  - 不加密的风险：**信息加密**
  - 不验证身份的风险：**身份证书**
  - 不验证完整性的风险：**校验机制**

- HTTPS如何解决三个风险
  - **混合加密**的方式实现信息的机密性，解决了**窃听**的风险
  - **摘要算法**的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了**篡改**的风险
  - 将**服务器公钥**放入到**数字证书**中，解决了冒充的风险
- HTTPS建立连接
  - SSL/TLS 协议基本流程
    - 客户端向服务器索要并验证服务器的公钥
    - 双方协商生产「会话秘钥」
    - 双方采用「会话秘钥」进行加密通信
  - SSL/TLS 的「握手阶段」涉及**四次通信**



## IP相关

- IP基本认识
  - IP的作用：在复杂的网络环境中将数据包发送到最终目的主机
  - 位于网络层：实现主机与主机之间的通信，也叫点对点（end to end）通信。
  - IP（网络层）与MAC（数据链路层）的区别
    - MAC 的作用则是实现**「直连」**的两个设备之间通信，而 IP 则负责在**「没有直连」**的两个网络之间进行通信传输
- IP基础知识
  - IP 地址（IPv4 地址）由 **32 位正整数**来表示，IP 地址在计算机是以二进制的方式处理的
  - IP地址分类
    <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210511144959816-1620715802974.png" alt="image-20210511144959816" style="zoom:67%;" />
  - 其中对于 A、B、C 类主要分为两个部分，分别是网络号和主机号。
    <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210511170216457-1620723738575.png" alt="image-20210511170216457" style="zoom:67%;" />
  
    - 主机号全为 1 指定某个网络下的所有主机，用于广播
    - 主机号全为 0 指定某个网络
  - 广播地址：用于在同一个链路中相互连接的主机之间发送数据包，主机号全为1
    - 在本网络内广播的叫作**本地广播**
    - 在不同网络之间的广播叫作**直接广播**
  - D 类常被用于多播，E 类是预留的分类，暂时未使用。
  <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210511171433739-1620724475905.png" alt="image-20210511171433739" style="zoom:67%;" />
  - 多播用于将包发送给特定组内的所有主机。

- DNS
  - DNS 域名解析：将域名网址自动转换为具体的 IP 地址。
  - 域名的层级关系类似一个树状结构：
    - 根 DNS 服务器
    - 顶级域 DNS 服务器（com）
    - 权威 DNS 服务器（server.com）
- ARP
  - 已知 IP 地址求 MAC 地址
  - 主机会通过广播发送 ARP 请求，这个包含了想要知道的 MAC 地址的主机 IP 地址。
  - 当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。
- RARP
  - 已知 MAC 地址求 IP 地址。
- DHCP
  - 服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码
- ICMP
  - ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。



## TCP

- TCP基本认识

<img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210511203857954.png" alt="image-20210511203857954" style="zoom:67%;" />

- **序列号**：在建立连接时由计算机生成的**随机数**作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决**网络包乱序问题**。
- **确认应答号**：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决不丢包的问题**。
- **控制位**
  - ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
  - RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
  - SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
  - FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。
- IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。
- TCP 是一个工作在**传输层**的**可靠数据传输的服务**，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的**。
- TCP 是**面向连接的、可靠的、基于字节流的传输层通信协议**。
  - 面向连接：一定是**「一对一」**才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
  - 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
  - 字节流：消息是**「没有边界」**的，所以无论我们消息有多大都可以进行传输。并且消息是**「有序的」**，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。
- TCP连接
  - 用于保证**可靠性**和**流量控制**维护的某些状态信息，这些信息的组合，包括**Socket、序列号和窗口大小**称为**连接**。
    - Socket：由 IP 地址和端口号组成
    - 序列号：用来解决乱序问题等
    - 窗口大小：用来做流量控制
  - TCP 四元组可以唯一的确定一个连接
    - 源地址
    - 源端口
    - 目的地址	
    - 目的端口
- TCP和UDP区别
  - **连接**
    - TCP 是面向连接的传输层协议，传输数据前先要建立连接。
    - UDP 是不需要连接，即刻传输数据。
  - **服务对象**
    - TCP是一对一的两点服务，即一条连接只有两个端点
    - UDP 支持一对一、一对多、多对多的交互通信
  - **可靠性**
    - TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达
    - UDP 是尽最大努力交付，不保证可靠交付数据
  - **拥塞控制、流量控制**
    - TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
    - UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
  - **首部开销**
    - TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 **20 个字节**，如果使用了「选项」字段则会变长的。
      - 首部长度占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是**32位字**（即以**4字节**的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是**60字节**，这也是TCP首部的最大字节（即**选项长度不能超过40字节**）。
    - UDP 首部只有 **8 个字节**，并且是固定不变的，开销较小。
  - **传输方式**
    - TCP 是流式传输，没有边界，但保证顺序和可靠。
    - UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
  - **分片不同**
    - TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
    - UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。

- TCP和UDP的应用场景
  - TCP：FTP 文件传输、HTTP / HTTPS
  - UDP：包总量较少的通信，如 DNS 、SNMP 等；视频、音频等多媒体通信；广播通信



## TCP连接建立

### **三次握手**
<img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210511210602750-1620738364173.png" alt="image-20210511210602750" style="zoom:67%;" />

- 客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN状态
- 第一次握手
  - 客户端随机初始化序号client_isn，**SYN**位设为1
  - 此次报文不携带任何数据，发送之后客户端处于SYN-SENT状态
- 第二次握手
  - 服务端收到客户端的SYN报文后，随机初始化序号server_isn，确认号设为client_isn+1，并将**ACK、SYN**位设为1
  - 此次报文不携带任何数据，发送之后服务端处于 SYN-RCVD 状态。
- 第三次握手
  - 客户端收到服务端报文后，确认号设为server_isn+1，并将**ACK**位设为1
  - 此次报文是可以携带数据的，发送之后客户端处于ESTABLISHED 状态，服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态

### **为什么需要三次握手？**

- 三次握手才可以**阻止重复历史连接的初始化（首要原因）**
  - 三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：
    - 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接
    - 如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接
- 三次握手才可以**同步双方的初始序列号**
  - 序列号是可靠传输的一个关键因素
    - 接收方可以去除重复的数据；
    - 接收方可以根据数据包的序列号按序接收；
    - 可以标识发送出去的数据包中， 哪些是已经被对方收到的；
- 三次握手才可以**避免资源浪费**
  - 如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。



### **不使用「两次握手」和「四次握手」的原因**

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。



### **既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？**

- MTU ：一个网络包的最大长度，以太网中一般为 1500 字节；
- MSS ：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 **TCP 数据的最大长度**；
- 当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的TCP 在超时后，就会重发「**整个 TCP 报文（头部 + 数据）**」。
- 为了达到最佳的传输效能 TCP 协议在建立连接的时候通常**要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了
- 经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。



## TCP连接断开

### 四次挥手
<img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210512102113555.png" alt="image-20210512102113555" style="zoom: 80%;" />

- 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 **FIN_WAIT_1** 状态
- 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 **CLOSED_WAIT** 状态
- 客户端收到服务端的 ACK 应答报文后，之后进入 **FIN_WAIT_2** 状态
- 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 **LAST_ACK** 状态
- 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 **TIME_WAIT** 状态
- 服务器收到了 ACK 应答报文后，就进入了 **CLOSED** 状态，至此服务端已经完成连接的关闭
- 客户端在经过 **2MSL** 一段时间后，自动进入 **CLOSED** 状态，至此客户端也完成连接的关闭

- **主动关闭连接的，才有 TIME_WAIT 状态**



### 为什么需要四次挥手？

- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示**客户端不再发送数据了但是还能接收数据**。
- 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接



### 为什么 TIME_WAIT 等待的时间是 2MSL？

- MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
- 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**
- 2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。
- 如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计
  时。



### 为什么需要 TIME_WAIT 状态？

- 只有主动发起关闭连接的一方才有TIME_WAIT状态

- 防止具有相同「四元组」的「旧」数据包被收到
  - 2MSL 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。
- 保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭



### TIME_WAIT 过多有什么危害？

- 第一是内存资源占用；
- 第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口
  - 如果发起连接一方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接



### TIME_WAIT优化

...



## Socket编程

![image-20210512104029787](C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210512104029787-1620787233442.png)

- 针对 TCP 应该如何 Socket 编程？
  - 服务端和客户端初始化 socket ，得到文件描述符；
  - 服务端调用 bind ，将绑定在 IP 地址和端口;
  - 服务端调用 listen ，进行监听；
  - 服务端调用 accept ，等待客户端连接；
  - 客户端调用 connect ，向服务器端的地址和端口发起连接请求；
  - 服务端 accept 返回用于传输的 socket 的文件描述符；
  - 客户端调用 write 写入数据；服务端调用 read 读取数据；
  - 客户端断开连接时，会调用 close ，那么服务端 read 读取数据的时候，就会读取到了EOF ，待处理完数据后，服务端调用 close ，表示连接关闭。

- 监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作**监听 socket**，一个叫作**已完成连接 socket**。
- 客户端 connect 成功返回是在**第二次握手**，服务端 accept 成功返回是在**三次握手成功**之后。



## TCP重传机制

### 超时重传

- 在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据

- TCP 会在以下两种情况发生超时重传：
  - 数据包丢失
  - 确认应答丢失
  
- 超时时间设置
  - RTT（Round-Trip Time 往返时延），数据从网络一端传送到另一端所需的时间，也就是**包的往返时间**
  - 超时重传时间是以 **RTO** （Retransmission Timeout 超时重传时间）表示
    - 当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；
    - 当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。
  - **超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**
    <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210512110820997-1620788902663.png" alt="image-20210512110820997" style="zoom:50%;" />
  - 「超时重传时间 RTO 的值」应该是一个**动态变化的值**
  
- 如果超时重发的数据，再次超时的时候，又需要重传的时候，**TCP 的策略是超时间隔加倍**
  - 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。
  
- 超时触发重传存在的问题是，超时周期可能相对较长

  

### 快速重传

- 不以时间为驱动，而是以**数据驱动重传**
  <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210512111648675.png" alt="image-20210512111648675" style="zoom:50%;" />
- 快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
- 快速重传机制只解决了一个问题，就是**超时时间的问题**，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。



### SACK方法

- Selective Acknowledgment 选择性确认，这种方式需要在 TCP 头部**「选项」**字段里加一个 **SACK** 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。

![image-20210512112803984](C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210512112803984.png)

### Duplicate SACK

- 又称 D-SACK ，其主要使用了 SACK 来**告诉「发送方」有哪些数据被重复接收了**
- 好处
  - 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
  2. 可以知道是不是「发送方」的数据包被网络延迟了;
  3. 可以知道网络中是不是把「发送方」的数据包给复制了;



## 滑动窗口

- 窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。
- 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除
- 通常窗口的大小是由**接收方的窗口大小**来决定的
- 发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。
- 接收窗口的大小是**约等于**发送窗口的大小



## 流量控制

- 让「发送方」根据「接收方」的实际接收能力控制发送的数据量
- 操作系统缓冲区与滑动窗口的关系
  - **发送窗口和接收窗口**中所存放的字节数，都是放在**操作系统内存缓冲区**中的，而操作系统的缓冲区，会被操作系统调整。
- 窗口关闭的死锁问题
  - 只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。
  - 如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。
- 糊涂窗口综合症
  - 接收方可以通告一个小的窗口
  - 而发送方可以发送小数据
  - 怎么让接收方不通告小窗口？
    - 接收方：当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0 ，也就阻止了发送方再发数据过来
  - 怎么让发送方避免发送小数据？
    - 使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：
      - 要等到窗口大小 >= MSS 或是 数据大小 >= MSS
      - 收到之前发送数据的 ack 回包



## 拥塞控制

### 为什么要有拥塞控制呀，不是有流量控制了吗？

- 流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么
- 在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....

- 拥塞控制目的：避免「发送方」的数据填满整个网络。

### 拥塞窗口

- **拥塞窗口 cwnd**是**发送方**维护的一个的状态变量，它会根据**网络的拥塞程度**动态变化的。
- 对于发送方，**发送窗口swnd = min(cwnd, rwnd)，拥塞窗口和接收窗口中的最小值**
- 拥塞窗口 cwnd 变化的规则：
  - 只要网络中没有出现拥塞， cwnd 就会增大；
  - 但网络中出现了拥塞， cwnd 就减少；



### 如何知道当前网络是否出现了拥塞？

- 其实**只要「发送方」没有在规定时间内接收到 ACK 应答报文**，也就是**发生了超时重传**，就会认为网络出现了用拥塞。



### 拥塞控制主要是四个算法

#### 慢启动

- **当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**

<img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210518144245410-1621320166654.png" alt="image-20210518144245410" style="zoom:67%;" />



- 慢启动算法，发包的个数是**指数性的增长**。

- 慢启动的阈值ssthresh：

  - 当 cwnd < ssthresh 时，使用慢启动算法。
  - 当 cwnd >= ssthresh 时，就会使用「**拥塞避免算法**」。

  - 一般来说 ssthresh 的大小是 65535 字节

#### 拥塞避免

- **每当发送方收到一个 ACK 时，cwnd 增加 1/cwnd。**

- 变为线性增加

- 拥塞避免算法就是将原本慢启动算法的**指数增长**变成了**线性增长**，还是增长阶段，但是增长速度缓慢了一些。

  <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210518144937175-1621320583782.png" alt="image-20210518144937175" style="zoom: 67%;" />

#### 拥塞发生

- 当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：
  - 超时重传
  - 快速重传
- 超时重传（反应也很强烈，会造成网络卡顿）
  - ssthresh 和 cwnd 的值会发生变化
    - **ssthresh 设为 cwnd/2**
    - **cwnd 重置为 1**

<img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210518145327211.png" alt="image-20210518145327211" style="zoom:67%;" />

- 快速重传
  - ssthresh 和 cwnd 变化如下：
    - cwnd = cwnd/2 ，也就是设置为原来的一半;
    - ssthresh = cwnd ;
    - 进入**快速恢复算法**



#### 快速恢复

- 快速恢复算法一般和快速重传一起使用
- 步骤
  - 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
  - 重传丢失的数据包；
  - 如果再收到重复的 ACK，那么 cwnd 增加 1；
  - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

<img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\image-20210518145914234.png" alt="image-20210518145914234" style="zoom:67%;" />

## TCP粘包、拆包

### TCP粘包、拆包表现形式

- 情况一：接收端正常收到两个数据包，即没有发生拆包和粘包的现象

<img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\20160722144359680" alt="img" style="zoom:67%;" />

- 情况二：接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。

  <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\20160722144417818" alt="img" style="zoom:67%;" />

- 情况三：这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。

  <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\20160722144437428" alt="img" style="zoom:67%;" />

  <img src="C:\Users\ln\OneDrive\校招准备\网络\Pic\20160722144453881" alt="img" style="zoom:67%;" />

### TCP粘包、拆包发生原因

- 滑动窗口
  - 粘包：假设发送方的每256 bytes表示一个完整的报文，**接收方由于数据处理不及时**，这256个字节的数据都会被缓存到SO_RCVBUF(接收缓存区）中。如果**接收方的SO_RCVBUF中缓存了多个报文**，那么对于接收方而言，这就是粘包。
  - 考虑另外一种情况，假设接收方的窗口只剩了128，意味着发送方最多还可以发送128字节，而由于发送方的数据大小是256字节，因此只能发送前128字节，等到接收方ack后，才能发送剩余字节。这就造成了拆包。（接收方的缓存区小于发送方发送的一个报文长度）
- MSS和MTU分片
  - **MSS:** 是Maximum Segement Size缩写，表示TCP报文中data部分的最大长度，是TCP协议在OSI五层网络模型中传输层对一次可以发送的最大数据的限制。
  - **MTU:** 最大传输单元是Maxitum Transmission Unit的简写，是OSI五层网络模型中链路层(datalink layer)对一次可以发送的最大数据的限制。