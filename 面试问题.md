[TOC]

## C++问题

### 1、STL 中关系型容器底层为什么使用红黑树而不是其它的平衡二叉树

- 其它的平衡二叉树主要是 **AVL 树**，AVL 树是高度平衡的树，其结构相较 **红黑树** 来说更为平衡，在插入和删除结点更容易引起树的 **不平衡**。因此在大量数据需要插入或者删除时，AVL 树需要 **rebalance** 的频率会更高，而 **红黑树** 在这类场景下，效率更高。
- 如果插入一个结点引起了树的不平衡，**AVL 树** 和 **红黑树** 都最多只需要 **2 次旋转操作**，即两者的时间复杂度都是 **$O(1)$**；但在删除结点引起树的不平衡时，最坏情况下，AVL 树需要维护从被删结点到根这条路径上所有节点的平衡性，因此旋转操作的时间复杂度量级是 **$O(log(N))$** ，而红黑树删除结点时最多只需要 **3 次旋转**，即时间复杂度为 **$O(1)$**；
- STL 中容器实现时折衷了两者在search、insert以及delete下的效率。总体来说，**红黑树的统计性能是高于 AVL 树的**。

### 2、C++ 多重继承及其优缺点？

- 多重继承的派生类继承了所有父类的属性。派生类的对象包含有每个基类的子对象。
- 构造一个派生类对象将同时构造并初始化它的所有 **直接基类** 的子对象。基类的构造顺序 **与派生列表中的顺序保持一致**。析构函数的调用顺序正好相反。
- 允许派生类从它的一个或几个基类中继承构造函数，但如果从多个基类中继承了相同的构造函数（即形参列表完全相同），会产生错误。如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数 **定义它自己的版本**。
- 编译器不会在派生类向基类的几种转换中进行比较和选择，在它看来转换到任意一种基类都一样好。
- 派生类可能从两个或更多基类中继承了同名成员，此时，不加前缀限定符直接使用会引发二义性错误，即使派生类继承的两个函数形参列表不同也可能发生错误。此外，即使同名函数在一个基类中是私有的，而在另一个基类中是公有的或受保护的，也会发生错误。因为 **先查找名字后进行类型检查，当编译器在两个作用域中同时发现了同名成员时，将直接报告一个二义性错误**。要避免这类错误，最好的办法时在派生类中为该函数 **定义一个新版本**。
- 默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。这对于某些类是行不通的。C++ 通过 **虚继承** 的机制解决上述问题。虚继承的目的是令某个类做出声明。承诺愿意共享它的基类。其中，共享的基类子对象称为 **虚基类**。
- 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，他不会影响派生类本身。
- 派生类的成员比共享虚基类中的同名成员优先级更高；但如果共享虚基类的成员被多于一个基类覆盖，则派生类必须为该成员定义一个新版本，否者会产生二义性错误。
- 在虚派生中，虚基类是由 **最底层的派生类初始化的** 并且在构造顺序中也是 **最优先的**。
- 一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序 **从左向右** 构造。

### 3、在构造函数和析构函数中使用虚函数会发生什么？

### 4、野指针/空悬指针

- 野指针不是空指针，而是指向一个垃圾内存的指针，或者说是指向一块曾经保存数据对象但现在已经无效的内存的指针。
- 形成原因：
  - 指针变量没有被初始化；任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。
  - 指针 p 被 free 或者 delete 之后，没有置为NULL，让人误以为 p 是个合法的指针。free 和delete 只是把指针所指的内存给释放掉，但并没有把指针本身干掉。free 以后其地址仍然不变。
  - 指针操作 **超越了变量的作用范围**。返回局部变量的地址，指针越界等。
- 动态内存的一个基本问题是可能有多个指针指向相同的内存，在 `delete` 内存之后重置指针只对这一个指针有效，对其他任何仍指向（已释放的）内存的指针是没有作用的。

### 5、sizeof

- 其作用是返回一个对象或类型所占的内存字节数。`sizeof` 对对象求内存大小，最终都是转换为对对象的数据类型进行求值。
- 结构体的 `sizeof` 涉及到 **字节对齐问题**。字节对齐有助于加快计算机的取数速度。因此，编译器会对结构体进行处理，让宽度为 2 的基本数据类型（`short` 等）都位于能被 2 整除的地址上，让宽度为 4 的基本数据类型（`int` 等）都位于能被 4 整除的地址上，依次类推。这样，两个数中间就可能需要加入填充字节，所以整个结构体的 `sizeof` 值就增长了：
  - 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
  - 结构体的每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节；
  - 结构体的总大小为结构体 **最宽基本类型成员大小的整数倍**，如有需要，编译器会在最末一个成员后加上填充字节。
- 空结构体（不含数据成员）的 `sizeof` 值为1。试想一个“不占空间“的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢，于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。只包含成员函数的类，其 `sizeof` 值也为 1， 因为成员函数只与类型相关，而与具体实例无关。
- 对象的存储空间等于 **非静态成员变量总和加上编译器为了 CPU 计算做出的数据对齐处理和支持虚函数所产生的负担的总和**。
- 联合体的 `sizeof` 是每个成员 `sizeof` 的最大值。
- 数组的 `sizeof` 值等于数组所占用的内存字节数：
  - 当字符数组表示字符串时，其 `sizeof` 值 **将 `’/0’` 计算进去**；
  - 当 **数组为形参** 时，其 `sizeof` 值相当于 **指针的 `sizeof` 值**。
- 指针的内存大小等于计算机内部 **地址总线的宽度**，在 32 位计算机中，一个指针变量的大小为 4。指针变量的 `sizeof` 值 **与指针所指的对象没有任何关系**。
- `sizeof` 也可对一个函数调用求值，其结果是 **函数返回值类型的大小**，函数并不会被调用。
  - 不可以对返回值类型为空的函数求值；
  - 不可以对函数名求值；
  - 对有参数的函数求值时，需写上实参表。

### 6、对象指针为NULL，为什么还是可以调用成员函数

- 类的成员函数并不与具体对象绑定，所有的对象共用同一份成员函数体，当程序被编译后，成员函数的地址即已确定，这份共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的 this 指针，成员函数中对成员变量的访问都是转化成 **"this->数据成员"** 的方式。因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的 this 指针。
- 当调用一个成员函数时，是用请求该函数的对象地址初始化 **this指针**。
- 类的静态成员函数只能访问静态成员变量，不能访问非静态成员变量，所以静态成员函数不需要指向对象的this指针作为隐式参数。
- 有虚函数的类会有一个成员变量，即虚表指针，当调用虚函数时，会使用虚表指针，对虚表指针的使用也是通过隐式指针使用的。

### 7、C++ 构造函数为什么不能是虚函数？

- 虚函数调用是在部分信息下完成工作的机制，它允许我们只知道接口而不知道对象的确切类型。要创建一个对象，你需要知道对象的完整信息。特别是，你需要知道你想要创建的确切类型。因此，构造函数不应该被定义为虚函数。
- 虚函数对应一个只想虚函数表 `vtable` 的指针，但是这个虚指针事实上是存储在对象的内存空间的。假设构造函数是虚函数，就需要虚函数表来调用，但是对象还没有实例化，即还没有内存空间，因此就没有初始化虚指针，找不到虚函数表。所以构造函数不能是虚函数。

### 8、面向对象程序设计

- **数据抽象、继承和动态绑定** 是其三个基本概念。
- 类的基本思想是 **数据抽象** 和 **封装**。数据抽象是一种依赖于 **接口** 和 **实现** 分离的编程技术。封装则实现了类的接口和实现的分离。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。
- **继承** 是我们可以更容易地定义与其它类相似但不完全相同的新类；
- **动态绑定** 使我们在使用这些彼此相似的类编写程序时，可以在一定程度上忽略它们的区别；
- 在 C++ 中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待；对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成 **虚函数**。
- **多态性** 是 OOP 的核心思想之一。把具有继承关系的多个类型称为多态类型，我们可以使用这些类型的 多种形式 而无须在意它们的差异。**引用或指针的静态类型与动态类型不同** 这一事实正是 C++ 支持多态性的根本所在。

### 9、string 类

- 由 C++ 字符串转换成对应的 C 字符串的方法是使用 `data()`、`c_str()` 和 `copy()` 来实现。`data()` 以字符数组的形式返回字符串内容，但并不添加 `\0`； `c_str()` 返回一个以 `\0` 结尾的字符数组；而 `copy()` 则把字符串的内容复制或写入既有的 `c_string` 或字符数组内。
- 使用 `c_str()` 和 `data()` 得到字符串 str 对应的字符数组 cstr 后，改变字符串 str 的内容，cstr 的内容也会随着改变。

### 10、红黑树

- 红黑树确保没有一条路径会比其它路径长出两倍，因而是接近平衡的；
- 红黑树左旋、右旋操作：

``` c++
inline void _rb_tree_rotate_left(_tb_tree_node_base *x, _rb_tree_node_base *&root) {
    // x 为旋转点
    _rb_tree_node_base *y = x->right;
    x->right = y->left;
    if (y->left != 0)
        y->left->parent = x;
    y->parent = x->parent;
    
    if (x == root)
        root = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;
    
    x->parent = y;
    y->left = x;
}

inline void _rb_tree_rotate_right(_tb_tree_node_base *x, _rb_tree_node_base *&root) {
    // x 为旋转点
    _rb_tree_node_base *y = x->left;
    x->left = y->right;
    if (y->right != 0)
        y->right->parent = x;
    y->parent = x->parent;
    
    if (x == root)
        root = y;
    else if (x == x->parent->right)
        x->parent->right = y;
    else
        x->parent->left = y;
    
    y->right = x;
    x->parent = y;
}
```

### 11、set

- 对于关联容器而言，插入和删除的一切操作都是指针指向变化，不需要做内存拷贝和内存移动，所以 `map` 和 `set` 的插入删除效率比其他序列容器高。
- `set` 和 `map` 的迭代器相当于指向结点的指针，插入操作不会改变已有指针指向的内存。
- 在 `set` 中查找使用的是 **二分查找**，即 $\log N$​ 的时间复杂度。当数据量增大了一倍时，搜索次数也只是多了一次。

### 12、关联容器中插入重复键值的处理方法？

- `map` 和 `set` 均调用底层 **红黑树** 的 `insert_unique` 函数，若检查发现键值重复，直接返回：

``` c++
return pair<iterator, bool>(j, false);
```

- `multimap` 和 `multiset` 则调用底层 **红黑树** 的 `insert_equal` 函数，允许节点键值重复，插入位置在已有重复键值节点的右子树上：

``` c++
iterator insert_equal(const Value &val) {
    link_type y = header;
    link_type x = root();
    while(x != 0) {
        y = x;
        x = key_compare(KeyOfValue()(v), key(x))? left(x) : right(x);
        // 遇“大”往左，遇“小于或等于”则往右
    }
    return __insert(x, y, v);
    // x 为新值插入点，y 为插入点的父节点，v 为新值
}
```

- `hash_set` 和 `hash_map` 调用底层 **`hash_table`** 的 `insert_unique` 函数，若检查发现键值重复，就不插入，立刻返回：

``` c++
return pair<iterator, bool>(iterator(cur, this), false);
```

- `hash_multimap` 和 `hash_multiset` 则是调用底层 **`hash_table`** 的 `insert_equal` 函数，允许节点键值重复，插入位置在已有重复键值节点之后：

``` c++
if (equals(get_key(cur->val), get_key(obj))) {
    node *tmp = new_node(obj);
    tmp->next = cur->next;
    cur->next = tmp;
    ++num_elements;
    return iterator(tmp, this);
}
```

### 13、字符数组和字符指针的区别：

- 字符指针是一个变量，可以改变它使它指向不同的字符串，但不能改变其所指的字符串常量
- 字符数组是一个数组，可以改变数组中保存的内容。

### 14、extern 关键字的用法

- `extern` 是指全局的意思，一般有两个用途
- **声明变量**：`extern` 声明不是定义，也不分配存储空间。事实上，它只是说明变量定义在程序的其他地方。程序中变量可以声明多次，但只能定义一次；只有当 `extern` 声明位于函数外部时，才可以含有初始化式。
- **声明 const 常量**：默认情况下，`const` 常量仅在文件内有效，当多个文件出现了同名的 `const` 变量时，相当于在不同文件中分别定义了独立的变量；通过指定 `const` 变量为 `extern`，就可以在多个文件之间共享`const` 对象；
- **显式实例化模板**：解决在多个文件中实例化相同模板的开销；当编译器遇到 `extern` 模板声明时，它不会在本文件中生成实例化代码；将一个实例化声明为 `extern` 表示承诺在程序其他位置有该实例化的一个非 `extern` 声明（定义）。

### 15、new 和 malloc 的区别

- new 操作符从 **自由存储区（free store）**上为对象动态分配内存空间，而 malloc 函数从 **堆上** 动态分配内存；特别的，new 甚至可以不为对象分配内存，如 **定位 new**；
- new 操作符内存分配成功时，返回的是 **对象类型的指针**，类型严格与对象匹配，无须进行类型转换，故 new是符合类型安全性的操作符；malloc 内存分配成功则是返回 **void *** ，需要通过强制类型转换将 void* 指针转换成我们需要的类型；
- new内存分配失败时，会抛出 **bac_alloc 异常**，它不会返回NULL；malloc 分配内存失败时返回 **NULL**；
- 使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会 **根据类型信息自行计算**；malloc 则需要 **显式地指出所需内存的尺寸**；
- new 操作符来分配对象内存时会经历三个步骤：
  - 调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象；
  - 编译器运行相应的构造函数以构造对象，并为其传入初值；
  - 对象构造完成后，返回一个指向该对象的指针；
- delete 操作符来释放对象内存时会经历两个步骤：
  - 调用对象的析构函数；
  - 编译器调用operator delete(或operator delete[])函数释放内存空间；
- malloc/free 来处理 C++ 的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适；
- new 对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数；至于 malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事；
- operator new /operator delete 的实现可以基于 malloc，而 malloc 的实现不可以去调用 new；
- opeartor new /operator delete 可以被重载，而 malloc/free 并不允许重载；
- 使用 malloc 分配的内存后，如果在使用过程中发现内存不足，可以使用 realloc 函数进行内存重新分配实现内存的扩充；
- 在 operator new 抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的 **错误处理函数**，这就是 **new-handler**；对于 malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着 malloc返回 NULL。

### 16、拷贝构造函数中参数为什么使用引用？

- 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化；
- 拷贝构造函数就是被用来初始化非引用类型的参数
- 如果其参数不是引用类型，则调用永远不会成功：为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，又需要调用拷贝构造函数，如此无限循环。

### 17、析构函数能不能是析构函数？

- 能
- 继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个 **虚析构函数**；
- 如果基类的析构函数不是虚函数，则 `delete` 一个指向派生类对象的基类指针将产生未定义的行为；

### 18、map 为什么用红黑树不用 B+ 树？相反，Mysql 为什么用 B+ 树不用红黑树？

- 树看重两个性能 **插入和查找**。插入时有可能要调整树的结构重新平衡树，B+树 调整树的结构慢一些，所以B+树插入慢，查找快；红黑树插入快 ，查找慢。
- 在 `map` 中， 核心不是查询效率，而是在修改的效率。`map` 的元素是动态修改的，红黑树修改元素，不用移动元素的位置，因为直接修改左右父指针的值就好了，但是B+树的同一个块内的元素，没有指针这个东西，所以修改元素就需要 **移动元素**，这个开销就很大了，也会 **触发频繁内存分配和回收**；
- Mysql中，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被 **存储在磁盘** 上。B+ 树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。19

### 19、static 关键字的作用

- **隐藏**：当同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性；如果加了static，就会对其它源文件隐藏，利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突；
- **保持变量内容的持久**：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它；
- 修饰 **全局变量**时，表明一个全局变量只对定义在同一文件中的函数可见；修饰 **局部变量**时，表明该变量的值不会因为函数终止而丢失；修饰 **函数** 时，表明该函数只在同一文件中调用；修饰 **类的数据成员**，表明对该类所有对象，这个数据成员都只有一个实例。即该实例归所有对象共有；修饰不访问非静态数据成员的 **类成员函数**，这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量；
- 在头文件把一个变量申明为static变量，那么引用该头文件的源文件能够访问到该变量吗？
  - 可以。声明static变量一般是为了在本cpp文件中的static变量不能被其他的cpp文件引用，但是对于头文件，因为cpp文件中包含了头文件，故相当于该static变量在本cpp文件中也可以被见到。**当多个cpp文件包含该头文件中，这个static变量将在各个cpp文件中将是独立的，彼此修改不会对相互有影响**。
- 为什么静态成员函数不能申明为 const？
  - const 修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，而一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分；
- 为什么不能在类的内部定义以及初始化 static 成员变量，而必须要放到类的外部定义？
  - 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的；
- static 关键字为什么只能出现在类内部的声明语句中，而不能重复出现在类外的定义中？
  - 如果类外定义函数时在函数名前加了static，因为作用域的限制，就只能在当前cpp里用，类本来就是为了给程序里各种地方用的，其他地方使用类是包含类的头文件，而无法包含类的源文件；
- 为什么常量静态成员数据的初始化可以放在类内？
- 为什么静态成员函数只能访问静态成员变量？
  - 静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的；
  - 非静态成员当且仅当实例化对象之后才存在，静态成员函数产生在前，非静态成员函数产生在后，故不能访问；
  - 内部访问静态成员用 `self::`，而访问非静态成员要用 `this指针`，静态成员函数没有this指针，故不能访问;
- 静态成员函数与非静态成员函数的区别:
  - 根本区别：静态成员函数不存在this指针，不能访问非静态成员变量。
- 为什么要用得静态成员变量和静态成员函数:
  - 为了实现共享。因为静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享;
- 静态成员函数的作用、优点：
  - 静态成员函数主要为了调用方便，不需要生成对象就能调用。

## 编译、调试

### 1、编译与链接的过程

- 编译与链接可以分解为 4 个步骤：**预处理、编译、汇编和链接**。

- 预处理过程主要处理源码文件以 `#` 开始的预编译指令，生成 `.i` 文件。比如 `#include`、`#define`：

  ``` c
  // -E 表示只执行到预编译，直接输出预编译结果
  g++ -E helloworld.cpp -o helloworld.i
  ```

  - 将所有的 `#define` 删除，并且展开所有的宏定义；
  - 处理所有条件预编译指令，比如 `#if`、`#ifdef`、`#elif`、`#else`、`#endif`；
  - 处理 `#include` 预编译指令，将被包含的文件插入到预编译指令的位置，这个过程是 **递归进行的**。

  - 过滤所有的注释；
  - 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；
  - 保留所有的 `#pragma` 编译器指令，因为编译器需要它们。

- 编译过程就是把预处理完的文件进行一系列的 **词法分析、语法分析、语义分析** 以及 **优化** 后产生的汇编代码文件，即 **未链接的目标文件**。

  ``` c
  // -S 表示只执行到源代码到汇编代码的转换
  g++ -S helloworld.i -o helloworld.s
  ```

  - 编译的过程一般分为 6 步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成和目标代码优化；

- 链接的主要内容是把各个模块之间相互引用的部分都处理好，把一些指令对其它符号地址的引用加以修正，使得各模块之间能够正确的衔接。

- 每个目标文件除了拥有自己的数据和二进制代码外，还提供了 3 个表：**未解决符号表、导出符号表、地址重定向表**：

  - 未解决符号表提供了所有在 **该编译单元里引用但是定义并不是在本编译单元的符号以及其出现的地址**；
  - 导出符号表提供了 **本编译单元里具有定义，并且愿意提供给其他单元使用的符号及其地址**；
  - 地址重定向表提供了 **本编译单元所有对自身地址的引用的记录**。

  编译器将 `extern` 声明的变量置入未解决符号表，这属于 **外部链接**；将 `static` 声明的全局变量不置入未解决符号表，也不置入导出符号表，因此其他单元无法使用，这属于 **内部链接**；普通变量及函数被置入导出符号表。

- 链接分为 **静态链接** 和 **动态链接**。对函数库的链接是放在 **编译时期完成** 的是静态链接。这些函数库称为静态库，通常文件命名为 `libxxx.a` 的形式。

  - 先将 `.cpp` 文件编译成 `.o` 文件；

  ``` c
  g++ -c add.cpp
  g++ -c sub.cpp
  ```

  - 由 `.o` 文件创建静态库

  ``` c
  ar cr libmymath.a sub.o add.o
  ```

  `ar` 命令的 `c` 选项是创建一个库，`r` 选项是在库中插入模块。

  - 在程序中使用静态库：

  ``` c
  g++ -o main main.cpp -L. -lmymath
  ```

- 把对一些 **库函数的链接推迟到程序运行时期**，这就是动态链接库。

  - 动态链接库的生成：

  ``` c
  g++ -fPIC -o add.o -c add.cpp
  g++ -fPIC -o sub.o -c sub.cpp
  g++ -shared -o libmymath.so add.o sub.o
      
  g++ -fPIC -shared -o libmymath.so add.cpp sub.cpp
      
  -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的，载入时是通过代码复制的方式来满足不同进程的需要，不是真正的共享;
  -Lpath：表示在 path 目录中搜索库文件，如 -L. 表示在当前目录;
  -Ipath：表示在 path 目录中搜索头文件;
  -ltest：查找库
  ```

  - 动态链接库的搜索路径顺序为：
    - 

- 静态库和动态库对比：
  - 动态链接库有利于进程间资源共享；
  - 链接动态库的程序升级时更简单，而静态库若发生变化，使用该库的程序要重新编译；
  - 动态库的链接载入可以完全由程序员在程序代码中控制；
  - 由于静态库在编译时就将库函数装到程序中了，所有程序执行时，速度更快些。

### 2、Makefile

[教程1](https://www.w3cschool.cn/mexvtg/xspwqozt.html)

[教程2](https://seisman.github.io/how-to-write-makefile/introduction.html)

### 3、gdb

- `gdb` 是 `gcc` 的调试工具，主要用于调试 C 和 C++ 这两种语言编写的程序。要调试 C/C++ 的程序，首先在编译时，必须要把调试信息加到可执行文件中。使用编译器的 `-g` 参数。如果没有 `-g` ，将看不见程序的函数名、变量名，所显示的全是运行时的内存地址。
- `gdb` 启动方法：
  - gdb program (core)/(PID)； 

- `gdb` 命令：
  - `l`：列出函数代码及其行数；
  - `b row`：在代码 `row` 行处设置断点；
  - `r`：运行程序；
  - `n`：单步执行语句；
  - `b func`：在函数 `func` 处设置断点；
  - `p i`：打印变量 `i` 的值；
  - `bt`：查看函数的堆栈；
  - `info break`：查看断点的信息；
  - `finish`：退出函数；
  - `q`：结束调试。

### 4、 用 gdb 分析 coredump 文件

- `coredump` 文件含有当进程被终止时内存、CPU 寄存器和各种函数调用堆栈信息。

- 产生 `coredump` 文件的原因：
  - 内存访问越界：使用错误的下标，导致数组访问越界；搜索字符串时，依靠字符串结束符控制程序结束，但是字符串没有正常的使用结束符；
  - 多线程程序使用了线程不安全的函数；
  - 多线程读写数据时未加锁保护；
  - 非法指针，包括使用空指针或随意使用指针转换；随意使用指针转换是指一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，否者不要将它转换为这种结构或类型的指针；
  - 堆栈溢出，不要使用大的局部变量（因为局部变量都分配在栈上）。

### 5、top 命令

- `top` 命令能够实时显示系统中各个进程的资源占用状况；
- 显示系统中 CPU 最敏感的任务列表，可以按 CPU 使用，内存使用和执行时间对任务进行排序。

### 6、ps 命令

- Linux 中的 `ps` 命令列出的是当前在运行的进程的快照，即执行 `ps` 命令的那个时刻，因此查看的结果并不动态连续；如果想要对进程时间监控，应该用 `top` 命令；
- Linux 上进程有 5 种状态及 `ps` 标识码：
  - 运行， ==R==；
  - 中断（休眠中，阻塞，在等待某个条件的形成或接收到信号）,==S==；
  - 不可中断，==D==；
  - 僵死（进程已终止，但进程描述符存在），==Z==；
  - 停止，==T==；

### 7、Linux 程序内存空间布局

- 一个典型的 Linux 下的 C 程序内存空间由如下几部分组成：

  - 代码段：用来存放程序执行代码的一块内存区域；
  - 初始化数据段：用来存放程序中 **已初始化的全局变量** 的一块内存区域，如所有函数外的全局变量；
  - 未初始化数据段：用来存放程序中 **未初始化的全局变量** 的一块内存区域。
  - 堆：用于存放进程运行中被 **动态分配的内存段**;
  - 栈：用来存放程序的 **局部变量**（不包括 `static` 声明的变量，`static` 意味着存放在数据段中）；在函数被调用时，用来传递参数和返回值。

- 堆栈的区别：

  - 申请方式不同：栈由 **系统自动分配**；堆需要程序员 **自己申请，并指明大小**。
  - 申请后系统的响应不同：
    - 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报异常；
    - 操作系统由一块记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个大于所申请空间的堆结点，然后将该节点从空闲结点链表中删除，并将该节点的空间分配给程序；其次，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样 `delete` 语句才能正确的释放本内存空间；最后，系统会自动地将多余的那部分内存空间重新放入空闲链表中；
  - 申请大小的限制不同：
    - 栈是向低地址扩展的数据结构，是一块 **连续的内存区域**，即栈顶的地址和栈的最大容量是系统预先规定好的；
    - 堆是向高地址扩展的数据结构，是 **不连续的内存区域**；堆的大小受限于计算机系统中有效的虚拟内存。
  - 申请效率不同：
    - 栈由系统自动分配，速度较快；
    - 堆是由 `new` 分配的内存，一般速度慢，而且容易产生内存碎片
  - 存储内容不同：
    - 函数调用时，第一个进栈的是主函数中的下一条指令的地址，然后是函数的各个参数（大多数 C 编译器中，参数是从右往左入栈的），然后是函数中的局部变量。
    - 一般是在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。


### 网络部分

### 1、TCP 如何保证传输可靠性？

- TCP 协议传输的特点是 **面向字节流、传输可靠、面向连接**；
- 其中， TCP 确保传输可靠性的方式主要有：**校验和、序列号/确认应答、超时重传、连接管理、流量控制和拥塞控制**；
- **校验和**：
  - 将发送的数据段都当作一个 16 位的整数，将这些整数加起来，并且前面的进位不丢弃，补在后面，最后取反；
  - 发送发负责在发送数据前计算校验和。并填充到头部的校验和字段；
  - 接收方收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行对比；

- **确认应答与序列号**：
  - TCP 传输时将每个字节的数据都进行了编号
  - TCP 传输的过程中，每次 接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文；
  - 有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。
- **超时重传**：
  - TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的；
  - TCP 第一次握手的 SYN 包超时重传最大次数是由 `tcp_syn_retries` 指定，默认值为 ==5 次==；第二次握手的 SYN、ACK 包超时重传最大次数是由 `tcp_synack_retries` 指定，默认值为 ==5 次==；TCP 建立连接后的数据包最大超时重传次数由 `tcp_retries2` 指定，默认值是 ==15次==；
- **连接管理**：三次握手和四次挥手；
- **流量控制**：TCP 根据接收端对数据的处理能力，决定发送端的发送速度；
  - 接收端会在确认应答发送 ACK 报文时，将自己的即时窗口大小填入，并跟随 ACK 报文一起发送过去；
  - 发送方根据 ACK 报文里的窗口大小的值的改变进而改变自己的发送速度；
  - 如果接收到窗口大小的值为 0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。
- **拥塞控制**：是可靠性的保证，同时也是维护了传输的高效性

## 系统部分

### 1、CPU 调度算法中的抢占式和非抢占式？

- 非抢占式：先来先服务、短作业优先、最高响应比优先；
- 抢占式：最短剩余时间优先、时间片轮转法、多级反馈队列

### 2、cache 存在的原因，多个 cpu 之间的 cache 如何保持一致的？

- CPU 的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU 常常需要等待主存，浪费资源。所以cache 的出现，是为了 **缓解 CPU 和内存之间速度的不匹配问题**；
- 既然 cache 不能包含 CPU 所需要的所有数据，那么 cache 的存在真的有意义吗？——有意义，**局部性原理**:
  - **时间局部性**：如果某个数据被访问，那么在不久的将来它很可能被再次访问
  - **空间局部性**：如果某个数据被访问，那么与它相邻的数据很快也可能被访问
- 缓存一致性：在多核CPU中，内存中的数据会在多个核心中存在数据副本，某一个核心发生修改操作，就产生了数据不一致的问题。而一致性协议正是用于保证多个CPU cache之间缓存共享数据的一致。
- **写传播**：某个 CPU 核⼼⾥的 Cache 数据更新时，必须要传播到其他核⼼的 Cache；
  - **总线嗅探**
- **事务串行化**：某个 CPU 核⼼⾥对数据的操作顺序，必须在其他核⼼看起来顺序是⼀样的；
- **MESI 协议**：*Modified、Exclusize、Shared、Invalidated*

<img src="https://i.loli.net/2021/08/13/o89qwpFPB1l672g.png" alt="MESI_CPU缓存一致性.PNG" style="zoom:80%;" />

### 3、select、poll、epoll对比

- `select` ==> 时间复杂度 $O(n)$
  - 它仅仅知道有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），只能 **无差别轮询所有流**，找出能读出数据，或者写入数据的流，对他们进行操作;
- `poll` ==> 时间复杂度 $O(n)$
  - `poll` 本质上和 `select` 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 `fd` 对应的设备状态， 但是它 **没有最大连接数的限制**，原因是它是 **基于链表来存储**的
- `epoll` ==> 时间复杂度 $O(1)$
  - `epoll` 可以理解为 `event poll`，不同于忙轮询和无差别轮询，`epoll` 会把哪个流发生了怎样的 I/O 事件通知我们。所以我们说 `epoll` 实际上是事件驱动（每个事件关联上 `fd`）的
- `epoll` 有 **EPOLLLT** 和 **EPOLLET** 两种触发模式，LT 是默认的模式，ET 是“高速”模式
  - LT 模式下，只要这个 `fd` 还有数据可读，每次 `epoll_wait` 都会返回它的事件，提醒用户程序去操作；
  - ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论 `fd` 中是否还有数据可读。所以在 ET 模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值;
  - 如果采用 LT 模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调 `epoll_wait` 都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率；而 ET 模式下，系统不会充斥大量你不关心的就绪文件描述符；
- `select` 的缺点：
  - 每次调用 `select`，都需要把 `fd` 集合从用户态拷贝到内核态，这个开销在 `fd` 很多时会很大；
  - 同时每次调用 `select` 都需要在内核遍历传递进来的所有 `fd`，这个开销在 `fd` 很多时也很大;
  - `select` 支持的文件描述符数量太小了，默认是1024。

- `epoll` 的优点：
  - **没有最大并发连接的限制**，能打开的FD的上限远大于1024；
  - 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用 `callback `函数；**即 epoll 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll 的效率就会远远高于 select 和 poll 。**
  - 内存拷贝，利用 `mmap()` 文件映射内存，加速与内核空间的消息传递；即 `epoll` 使用 `mmap` 减少复制开销。

### 4、进程都有哪些资源

- 一个进程拥有独立的地址空间（代码段、数据段），打开的文件描述符、自身的信号处理器、进程控制块，进程通信的一些资源

### 5、线程与进程的区别：

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间；
- 同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的；
- 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都会死掉。所以多进程要比多线程健壮；
- 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程；
- 每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

### 6、多进程与多线程的区别以及选择

