[TOC]

## C++问题

### 1、STL 中关系型容器底层为什么使用红黑树而不是其它的平衡二叉树

- 其它的平衡二叉树主要是 **AVL 树**，AVL 树是高度平衡的树，其结构相较 **红黑树** 来说更为平衡，在插入和删除结点更容易引起树的 **不平衡**。因此在大量数据需要插入或者删除时，AVL 树需要 **rebalance** 的频率会更高，而 **红黑树** 在这类场景下，效率更高。
- 如果插入一个结点引起了树的不平衡，**AVL 树** 和 **红黑树** 都最多只需要 **2 次旋转操作**，即两者的时间复杂度都是 **$O(1)$**；但在删除结点引起树的不平衡时，最坏情况下，AVL 树需要维护从被删结点到根这条路径上所有节点的平衡性，因此旋转操作的时间复杂度量级是 **$O(log(N))$** ，而红黑树删除结点时最多只需要 **3 次旋转**，即时间复杂度为 **$O(1)$**；
- STL 中容器实现时折衷了两者在search、insert以及delete下的效率。总体来说，**红黑树的统计性能是高于 AVL 树的**。

### 2、C++ 多重继承及其优缺点？

- 多重继承的派生类继承了所有父类的属性。派生类的对象包含有每个基类的子对象。
- 构造一个派生类对象将同时构造并初始化它的所有 **直接基类** 的子对象。基类的构造顺序 **与派生列表中的顺序保持一致**。析构函数的调用顺序正好相反。
- 允许派生类从它的一个或几个基类中继承构造函数，但如果从多个基类中继承了相同的构造函数（即形参列表完全相同），会产生错误。如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数 **定义它自己的版本**。
- 编译器不会在派生类向基类的几种转换中进行比较和选择，在它看来转换到任意一种基类都一样好。
- 派生类可能从两个或更多基类中继承了同名成员，此时，不加前缀限定符直接使用会引发二义性错误，即使派生类继承的两个函数形参列表不同也可能发生错误。此外，即使同名函数在一个基类中是私有的，而在另一个基类中是公有的或受保护的，也会发生错误。因为 **先查找名字后进行类型检查，当编译器在两个作用域中同时发现了同名成员时，将直接报告一个二义性错误**。要避免这类错误，最好的办法时在派生类中为该函数 **定义一个新版本**。
- 默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。这对于某些类是行不通的。C++ 通过 **虚继承** 的机制解决上述问题。虚继承的目的是令某个类做出声明。承诺愿意共享它的基类。其中，共享的基类子对象称为 **虚基类**。
- 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，他不会影响派生类本身。
- 派生类的成员比共享虚基类中的同名成员优先级更高；但如果共享虚基类的成员被多于一个基类覆盖，则派生类必须为该成员定义一个新版本，否者会产生二义性错误。
- 在虚派生中，虚基类是由 **最底层的派生类初始化的** 并且在构造顺序中也是 **最优先的**。
- 一个类可以有多个虚基类。此时，这些虚的子对象 按照它们在派生列表中出现的顺序 **从左向右** 构造。

### 3、在构造函数和析构函数中使用虚函数会发生什么？

### 4、野指针

- 野指针不是空指针，而是指向一个垃圾内存的指针。
- 形成原因：
  - 指针变量没有被初始化；任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。
  - 指针 p 被 free 或者 delete 之后，没有置为NULL，让人误以为 p 是个合法的指针。free 和delete 只是把指针所指的内存给释放掉，但并没有把指针本身干掉。free 以后其地址仍然不变。
  - 指针操作 **超越了变量的作用范围**。返回局部变量的地址，指针越界等。

### 5、sizeof

- 其作用是返回一个对象或类型所占的内存字节数。`sizeof` 对对象求内存大小，最终都是转换为对对象的数据类型进行求值。
- 结构体的 `sizeof` 涉及到 **字节对齐问题**。字节对齐有助于加快计算机的取数速度。因此，编译器会对结构体进行处理，让宽度为 2 的基本数据类型（`short` 等）都位于能被 2 整除的地址上，让宽度为 4 的基本数据类型（`int` 等）都位于能被 4 整除的地址上，依次类推。这样，两个数中间就可能需要加入填充字节，所以整个结构体的 `sizeof` 值就增长了：
  - 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
  - 结构体的每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节；
  - 结构体的总大小为结构体 **最宽基本类型成员大小的整数倍**，如有需要，编译器会在最末一个成员后加上填充字节。
- 空结构体（不含数据成员）的 `sizeof` 值为1。试想一个“不占空间“的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢，于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。只包含成员函数的类，其 `sizeof` 值也为 1， 因为成员函数只与类型相关，而与具体实例无关。
- 对象的存储空间等于 **非静态成员变量总和加上编译器为了 CPU 计算做出的数据对齐处理和支持虚函数所产生的负担的总和**。
- 联合体的 `sizeof` 是每个成员 `sizeof` 的最大值。
- 数组的 `sizeof` 值等于数组所占用的内存字节数：
  - 当字符数组表示字符串时，其 `sizeof` 值 **将 `’/0’` 计算进去**；
  - 当 **数组为形参** 时，其 `sizeof` 值相当于 **指针的 `sizeof` 值**。
- 指针的内存大小等于计算机内部 **地址总线的宽度**，在 32 位计算机中，一个指针变量的大小为 4。指针变量的 `sizeof` 值 **与指针所指的对象没有任何关系**。
- `sizeof` 也可对一个函数调用求值，其结果是 **函数返回值类型的大小**，函数并不会被调用。
  - 不可以对返回值类型为空的函数求值；
  - 不可以对函数名求值；
  - 对有参数的函数求值时，需写上实参表。

### 6、对象指针为NULL，为什么还是可以调用成员函数

- 类的成员函数并不与具体对象绑定，所有的对象共用同一份成员函数体，当程序被编译后，成员函数的地址即已确定，这份共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的 this 指针，成员函数中对成员变量的访问都是转化成 **"this->数据成员"** 的方式。因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的 this 指针。
- 当调用一个成员函数时，是用请求该函数的对象地址初始化 **this指针**。
- 类的静态成员函数只能访问静态成员变量，不能访问非静态成员变量，所以静态成员函数不需要指向对象的this指针作为隐式参数。
- 有虚函数的类会有一个成员变量，即虚表指针，当调用虚函数时，会使用虚表指针，对虚表指针的使用也是通过隐式指针使用的。

### 7、C++ 构造函数为什么不能是虚函数？

- 虚函数调用是在部分信息下完成工作的机制，它允许我们只知道接口而不知道对象的确切类型。要创建一个对象，你需要知道对象的完整信息。特别是，你需要知道你想要创建的确切类型。因此，构造函数不应该被定义为虚函数。
- 虚函数对应一个只想虚函数表 `vtable` 的指针，但是这个虚指针事实上是存储在对象的内存空间的。假设构造函数是虚函数，就需要虚函数表来调用，但是对象还没有实例化，即还没有内存空间，因此就没有初始化虚指针，找不到虚函数表。所以构造函数不能是虚函数。

### 8、面向对象程序设计

- **数据抽象、继承和动态绑定** 是其三个基本概念。
- 类的基本思想是 **数据抽象** 和 **封装**。数据抽象是一种依赖于 **接口** 和 **实现** 分离的编程技术。封装则实现了类的接口和实现的分离。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。
- **继承** 是我们可以更容易地定义与其它类相似但不完全相同的新类；
- **动态绑定** 使我们在使用这些彼此相似的类编写程序时，可以在一定程度上忽略它们的区别；
- 在 C++ 中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待；对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成 **虚函数**。
- **多态性** 是 OOP 的核心思想之一。把具有继承关系的多个类型称为多态类型，我们可以使用这些类型的 多种形式 而无须在意它们的差异。**引用或指针的静态类型与动态类型不同** 这一事实正是 C++ 支持多态性的根本所在。

### 9、string 类

- 由 C++ 字符串转换成对应的 C 字符串的方法是使用 `data()`、`c_str()` 和 `copy()` 来实现。`data()` 以字符数组的形式返回字符串内容，但并不添加 `\0`； `c_str()` 返回一个以 `\0` 结尾的字符数组；而 `copy()` 则把字符串的内容复制或写入既有的 `c_string` 或字符数组内。
- 使用 `c_str()` 和 `data()` 得到字符串 str 对应的字符数组 cstr 后，改变字符串 str 的内容，cstr 的内容也会随着改变。

### 10、红黑树

- 红黑树确保没有一条路径会比其它路径长出两倍，因而是接近平衡的；
- 红黑树左旋、右旋操作：

``` c++
inline void _rb_tree_rotate_left(_tb_tree_node_base *x, _rb_tree_node_base *&root) {
    // x 为旋转点
    _rb_tree_node_base *y = x->right;
    x->right = y->left;
    if (y->left != 0)
        y->left->parent = x;
    y->parent = x->parent;
    
    if (x == root)
        root = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;
    
    x->parent = y;
    y->left = x;
}

inline void _rb_tree_rotate_right(_tb_tree_node_base *x, _rb_tree_node_base *&root) {
    // x 为旋转点
    _rb_tree_node_base *y = x->left;
    x->left = y->right;
    if (y->right != 0)
        y->right->parent = x;
    y->parent = x->parent;
    
    if (x == root)
        root = y;
    else if (x == x->parent->right)
        x->parent->right = y;
    else
        x->parent->left = y;
    
    y->right = x;
    x->parent = y;
}
```

### 11、set

- 对于关联容器而言，插入和删除的一切操作都是指针指向变化，不需要做内存拷贝和内存移动，所以 `map` 和 `set` 的插入删除效率比其他序列容器高。
- `set` 和 `map` 的迭代器相当于指向结点的指针，插入操作不会改变已有指针指向的内存。
- 在 `set` 中查找使用的是 **二分查找**，即 $\log N$​ 的时间复杂度。当数据量增大了一倍时，搜索次数也只是多了一次。

### 12、关联容器中插入重复键值的处理方法？

- `map` 和 `set` 均调用底层 **红黑树** 的 `insert_unique` 函数，若检查发现键值重复，直接返回：

``` c++
return pair<iterator, bool>(j, false);
```

- `multimap` 和 `multiset` 则调用底层 **红黑树** 的 `insert_equal` 函数，允许节点键值重复，插入位置在已有重复键值节点的右子树上：

``` c++
iterator insert_equal(const Value &val) {
    link_type y = header;
    link_type x = root();
    while(x != 0) {
        y = x;
        x = key_compare(KeyOfValue()(v), key(x))? left(x) : right(x);
        // 遇“大”往左，遇“小于或等于”则往右
    }
    return __insert(x, y, v);
    // x 为新值插入点，y 为插入点的父节点，v 为新值
}
```

- `hash_set` 和 `hash_map` 调用底层 **`hash_table`** 的 `insert_unique` 函数，若检查发现键值重复，就不插入，立刻返回：

``` c++
return pair<iterator, bool>(iterator(cur, this), false);
```

- `hash_multimap` 和 `hash_multiset` 则是调用底层 **`hash_table`** 的 `insert_equal` 函数，允许节点键值重复，插入位置在已有重复键值节点之后：

``` c++
if (equals(get_key(cur->val), get_key(obj))) {
    node *tmp = new_node(obj);
    tmp->next = cur->next;
    cur->next = tmp;
    ++num_elements;
    return iterator(tmp, this);
}
```

## 编译、调试

### 1、编译与链接的过程

- 编译与链接可以分解为 4 个步骤：**预处理、编译、汇编和链接**。

- 预处理过程主要处理源码文件以 `#` 开始的预编译指令，生成 `.i` 文件。比如 `#include`、`#define`：

  ``` c
  // -E 表示只执行到预编译，直接输出预编译结果
  g++ -E helloworld.cpp -o helloworld.i
  ```

  - 将所有的 `#define` 删除，并且展开所有的宏定义；
  - 处理所有条件预编译指令，比如 `#if`、`#ifdef`、`#elif`、`#else`、`#endif`；
  - 处理 `#include` 预编译指令，将被包含的文件插入到预编译指令的位置，这个过程是 **递归进行的**。

  - 过滤所有的注释；
  - 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；
  - 保留所有的 `#pragma` 编译器指令，因为编译器需要它们。

- 编译过程就是把预处理完的文件进行一系列的 **词法分析、语法分析、语义分析** 以及 **优化** 后产生的汇编代码文件，即 **未链接的目标文件**。

  ``` c
  // -S 表示只执行到源代码到汇编代码的转换
  g++ -S helloworld.i -o helloworld.s
  ```

  - 编译的过程一般分为 6 步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成和目标代码优化；

- 链接的主要内容是把各个模块之间相互引用的部分都处理好，把一些指令对其它符号地址的引用加以修正，使得各模块之间能够正确的衔接。

- 每个目标文件除了拥有自己的数据和二进制代码外，还提供了 3 个表：**未解决符号表、导出符号表、地址重定向表**：

  - 未解决符号表提供了所有在 **该编译单元里引用但是定义并不是在本编译单元的符号以及其出现的地址**；
  - 导出符号表提供了 **本编译单元里具有定义，并且愿意提供给其他单元使用的符号及其地址**；
  - 地址重定向表提供了 **本编译单元所有对自身地址的引用的记录**。

  编译器将 `extern` 声明的变量置入未解决符号表，这属于 **外部链接**；将 `static` 声明的全局变量不置入未解决符号表，也不置入导出符号表，因此其他单元无法使用，这属于 **内部链接**；普通变量及函数被置入导出符号表。

- 链接分为 **静态链接** 和 **动态链接**。对函数库的链接是放在 **编译时期完成** 的是静态链接。这些函数库称为静态库，通常文件命名为 `libxxx.a` 的形式。

  - 先将 `.cpp` 文件编译成 `.o` 文件；

  ``` c
  g++ -c add.cpp
  g++ -c sub.cpp
  ```

  - 由 `.o` 文件创建静态库

  ``` c
  ar cr libmymath.a sub.o add.o
  ```

  `ar` 命令的 `c` 选项是创建一个库，`r` 选项是在库中插入模块。

  - 在程序中使用静态库：

  ``` c
  g++ -o main main.cpp -L. -lmymath
  ```

- 把对一些库函数的链接推迟到程序运行时期，这就是动态链接库。

  - 动态链接库的生成：

  ``` c
  g++ -fPIC -o add.o -c add.cpp
  g++ -fPIC -o sub.o -c sub.cpp
  g++ -shared -o libmymath.so add.o sub.o
      
  g++ -fPIC -shared -o libmymath.so add.cpp sub.cpp
      
  -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的，载入时是通过代码复制的方式来满足不同进程的需要，不是真正的共享;
  -Lpath：表示在 path 目录中搜索库文件，如 -L. 表示在当前目录;
  -Ipath：表示在 path 目录中搜索头文件;
  -ltest：查找库
  ```

  - 动态链接库的搜索路径顺序为：
    - 

- 静态库和动态库对比：
  - 动态链接库有利于进程间资源共享；
  - 链接动态库的程序升级时更简单，而静态库若发生变化，使用该库的程序要重新编译；
  - 动态库的链接载入可以完全由程序员在程序代码中控制；
  - 由于静态库在编译时就将库函数装到程序中了，所有程序执行时，速度更快些。

### 2、Makefile

[教程1](https://www.w3cschool.cn/mexvtg/xspwqozt.html)

[教程2](https://seisman.github.io/how-to-write-makefile/introduction.html)

### 3、gdb

- `gdb` 是 `gcc` 的调试工具，主要用于调试 C 和 C++ 这两种语言编写的程序。要调试 C/C++ 的程序，首先在编译时，必须要把调试信息加到可执行文件中。使用编译器的 `-g` 参数。如果没有 `-g` ，将看不见程序的函数名、变量名，所显示的全是运行时的内存地址。
- `gdb` 启动方法：
  - gdb program (core)/(PID)； 

- `gdb` 命令：
  - `l`：列出函数代码及其行数；
  - `b row`：在代码 `row` 行处设置断点；
  - `r`：运行程序；
  - `n`：单步执行语句；
  - `b func`：在函数 `func` 处设置断点；
  - `p i`：打印变量 `i` 的值；
  - `bt`：查看函数的堆栈；
  - `info break`：查看断点的信息；
  - `finish`：退出函数；
  - `q`：结束调试。

### 4、 用 gdb 分析 coredump 文件

- `coredump` 文件含有当进程被终止时内存、CPU 寄存器和各种函数调用堆栈信息。

- 产生 `coredump` 文件的原因：
  - 内存访问越界：使用错误的下标，导致数组访问越界；搜索字符串时，依靠字符串结束符控制程序结束，但是字符串没有正常的使用结束符；
  - 多线程程序使用了线程不安全的函数；
  - 多线程读写数据时未加锁保护；
  - 非法指针，包括使用空指针或随意使用指针转换；随意使用指针转换是指一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，否者不要将它转换为这种结构或类型的指针；
  - 堆栈溢出，不要使用大的局部变量（因为局部变量都分配在栈上）。

### 5、top 命令

- `top` 命令能够实时显示系统中各个进程的资源占用状况；
- 显示系统中 CPU 最敏感的任务列表，可以按 CPU 使用，内存使用和执行时间对任务进行排序。

### 6、ps 命令

- Linux 中的 `ps` 命令列出的是当前在运行的进程的快照，即执行 `ps` 命令的那个时刻，因此查看的结果并不动态连续；如果想要对进程时间监控，应该用 `top` 命令；
- Linux 上进程有 5 种状态及 `ps` 标识码：
  - 运行， ==R==；
  - 中断（休眠中，阻塞，在等待某个条件的形成或接收到信号）,==S==；
  - 不可中断，==D==；
  - 僵死（进程已终止，但进程描述符存在），==Z==；
  - 停止，==T==；

### 7、Linux 程序内存空间布局

- 一个典型的 Linux 下的 C 程序内存空间由如下几部分组成：

  - 代码段：用来存放程序执行代码的一块内存区域；
  - 初始化数据段：用来存放程序中 **已初始化的全局变量** 的一块内存区域，如所有函数外的全局变量；
  - 未初始化数据段：用来存放程序中 **未初始化的全局变量** 的一块内存区域。
  - 堆：用于存放进程运行中被 **动态分配的内存段**;
  - 栈：用来存放程序的 **局部变量**（不包括 `static` 声明的变量，`static` 意味着存放在数据段中）；在函数被调用时，用来传递参数和返回值。

- 堆栈的区别：

  - 申请方式不同：栈由 **系统自动分配**；堆需要程序员 **自己申请，并指明大小**。
  - 申请后系统的响应不同：
    - 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报异常；
    - 操作系统由一块记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个大于所申请空间的堆结点，然后将该节点从空闲结点链表中删除，并将该节点的空间分配给程序；其次，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样 `delete` 语句才能正确的释放本内存空间；最后，系统会自动地将多余的那部分内存空间重新放入空闲链表中；
  - 申请大小的限制不同：
    - 栈是向低地址扩展的数据结构，是一块 **连续的内存区域**，即栈顶的地址和栈的最大容量是系统预先规定好的；
    - 堆是向高地址扩展的数据结构，是 **不连续的内存区域**；堆的大小受限于计算机系统中有效的虚拟内存。
  - 申请效率不同：
    - 栈由系统自动分配，速度较快；
    - 堆是由 `new` 分配的内存，一般速度慢，而且容易产生内存碎片
  - 存储内容不同：
    - 函数调用时，第一个进栈的是主函数中的下一条指令的地址，然后是函数的各个参数（大多数 C 编译器中，参数是从右往左入栈的），然后是函数中的局部变量。
    - 一般是在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。


### 网络部分

### 1、TCP 如何保证传输可靠性？

- TCP 协议传输的特点是 **面向字节流、传输可靠、面向连接**；
- 其中， TCP 确保传输可靠性的方式主要有：**校验和、序列号/确认应答、超时重传、连接管理、流量控制和拥塞控制**；
- **校验和**：
  - 将发送的数据段都当作一个 16 位的整数，将这些整数加起来，并且前面的进位不丢弃，补在后面，最后取反；
  - 发送发负责在发送数据前计算校验和。并填充到头部的校验和字段；
  - 接收方收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行对比；

- **确认应答与序列号**：
  - TCP 传输时将每个字节的数据都进行了编号
  - TCP 传输的过程中，每次 接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文；
  - 有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。
- **超时重传**：
  - TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的；
  - TCP 第一次握手的 SYN 包超时重传最大次数是由 `tcp_syn_retries` 指定，默认值为 ==5 次==；第二次握手的 SYN、ACK 包超时重传最大次数是由 `tcp_synack_retries` 指定，默认值为 ==5 次==；TCP 建立连接后的数据包最大超时重传次数由 `tcp_retries2` 指定，默认值是 ==15次==；
- **连接管理**：三次握手和四次挥手；
- **流量控制**：TCP 根据接收端对数据的处理能力，决定发送端的发送速度；
  - 接收端会在确认应答发送 ACK 报文时，将自己的即时窗口大小填入，并跟随 ACK 报文一起发送过去；
  - 发送方根据 ACK 报文里的窗口大小的值的改变进而改变自己的发送速度；
  - 如果接收到窗口大小的值为 0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。
- **拥塞控制**：是可靠性的保证，同时也是维护了传输的高效性
