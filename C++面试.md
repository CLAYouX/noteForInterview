# C++面试

## 堆和栈

- 一个由C/C++编译的程序占用的内存分为以下几个部分：
  - **栈区（stack）**：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
  - **堆区（heap）**：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是**类似于链表**。
  - **全局区（静态区）（static）**：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，  未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放
  - **文字常量区** ：常量字符串就是放在这里的，程序结束后由系统释放
  - **程序代码区**：存放函数体的二进制代码

### 堆和栈的理论知识

- 申请方式

    - 栈：由系统自动分配

    - 堆：需要程序员自己申请，并指明大小，在C中malloc函数；在C++中用new运算符

    - 例如

      `p1  =  (char  *)malloc(10); `

      `p2  =  new  char[10]; `

      *注意p1、p2本身是在栈中的*

- 申请后的系统响应

    - 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
    - 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

- 申请大小的限制
  - 栈：在Windows下,栈是向**低地址扩展**的数据结构，是**一块连续的内存的区域**。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。  
  -  堆：堆是向**高地址扩展**的数据结构，是**不连续的内存区域**。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。  
- 申请效率的比较
  - 栈：由系统自动分配，速度较快，但程序员是无法控制的。
  - 堆：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便；另外，在Windows下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈，是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 
- 堆和栈中的存储内容
  - 栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，**参数是由右往左入栈的**，然后是函数中的局部变量。注意**静态变量是不入栈**的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
  - 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。
- 存取效率的比较 
  
  - 在存取中，在栈上的数组比指针所指向的字符串(例如堆)快



## this指针

- `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
- `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
- `this` 并不是一个常规变量，而是个**右值**，所以不能取得 `this` 的地址（不能 `&this`）
- 在以下场景中，经常需要显式引用 `this` 指针：
  - 为实现对象的**链式引用**；
  - 为避免对同一对象进行赋值操作；
  - 在实现一些数据结构时，如 `list`。



## inline函数

- 在类声明中定义的函数，除了虚函数的其他函数都会**自动隐式地当成内联函数**。
- 编译器对 inline 函数的处理步骤
  - 将 inline 函数体复制到 inline 函数调用点处；
  - 为所用 inline 函数中的局部变量分配内存空间；
  - 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
  - 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。
- 优点
  - 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
  - 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
  - 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
  - 内联函数在运行时可调试，而宏定义不可以。
- 缺点
  - 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
  - inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
  - 是否内联，程序员不可控。**内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器**。

- 虚函数（virtual ）可以是内联函数？
  - 虚函数可以是内联函数，内联是可以修饰虚函数的，但是**当虚函数表现多态性的时候不能内联**。
  - 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
  - `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。



## volatile

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile



## sizeof()

- sizeof 对数组，得到整个数组所占空间大小。
- sizeof 对指针，得到指针本身所占空间大小。



## #pragma pack(n)

- 设定结构体、联合以及类成员变量以 n 字节方式对齐



## 位域：

```cpp
Bit mode: 2;    // mode 占 2 位
```

- **类可以将其（非静态）数据成员定义为位域（bit-field）**，在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。
  - 位域在内存中的布局是与机器有关的
  - 位域的类型必须**是整型或枚举类型**，带符号类型中的位域的行为将因具体实现而定
  - 取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域



## extern "C"

- 被 extern 限定的函数或变量是 extern 类型的
- 被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的
- `extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ **因符号修饰导致代码不能和C语言库中的符号进行链接的问题**。



## C++中的struct和class

- 总的来说，struct 更适合看成是一个**数据结构的实现体**，class 更适合看成是一个**对象的实现体**。
- 区别
  - 最本质的一个区别就是默认的访问控制
  - 默认的**继承访问权限**。struct 是 public 的，class 是 private 的。
  - struct 作为数据结构的实现体，它默认的数据访问控制是 **public** 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 **private** 的。



## union 联合

- 联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是**在任意时刻只有一个数据成员可以有值**，**当某个成员被赋值后其他成员变为未定义状态**。联合有如下特点：

  - 默认访问控制符为 public
  - 可以含有构造函数、析构函数
  - 不能含有引用类型的成员
  - 不能继承自其他类，不能作为基类
  - 不能含有虚函数
  - 匿名 union 在定义所在作用域可直接访问 union 成员
  - 匿名 union 不能包含 protected 成员或 private 成员
  - 全局匿名联合必须是静态（static）的

  

## C实现C++类

C 实现 C++ 的面向对象特性（封装、继承、多态）

- 封装：使用函数指针把属性与方法封装到结构体中
- 继承：结构体嵌套
- 多态：父类与子类方法的函数指针不同

[看这里](https://www.cnblogs.com/zzdbullet/p/10563075.html)和[这里](https://stackoverflow.com/questions/351733/how-would-one-write-object-oriented-code-in-c/351745#351745)



## 左值和右值

- 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。
- 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。



## 引用

### 左值引用

- 常规引用，一般表示对象的身份。

### 右值引用

- 右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。
- 和声明左值引用一样，右值引用也必须立即进行初始化操作，且**只能使用右值进行初始化**
- 和常量左值引用不同的是，**右值引用还可以对右值进行修改**
- 右值引用可实现**移动语义**（Move Sementics）和**完美转发**（Perfect Forwarding），它的主要目的有两个方面：
  - 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
  - 能够更简洁明确地定义泛型函数。



## 移动语义

- 以**移动而非深拷贝**的方式初始化含有指针成员的类对象，用**同类的右值对象（可以是匿名对象）**初始化新对象
- 移动语义指的就是将其他对象（**通常是临时对象**）拥有的内存资源“移为已用”
- 对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。
- 使用**移动构造函数**实现移动语义
- 当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。



## std::move()函数:将左值强制转换为右值

- move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将**某个左值强制转化为右值**

```cpp
move( arg )
```

- 其中，arg 表示指定的**左值对象**。该函数会返回 arg 对象的**右值形式**。



## 完美转发

- 完美转发，它指的是**函数模板**可以将自己的参数“完美”地转发给内部调用的其它函数。
- 所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。

```cpp
template<typename T>
void function(T t) 
{
    otherdef(t);
}
```

如上所示，function() 函数模板中调用了 otherdef() 函数。在此基础上，完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。

- C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。
- 但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为**“万能引用”**）。
- 引用折叠规则
  - 当实参为左值或者左值引用（A&）时，函数模板中 T&& 将转变为 A&（A& && = A&）；
  - 当实参为右值或者右值引用（A&&）时，函数模板中 T&& 将转变为 A&&（A&& && = A&&）。
- forword() 函数模板用于修饰被调用函数中需要维持参数左、右值属性的参数

```cpp
#include <iostream>
using namespace std;

//重载被调用函数，查看完美转发的效果
void otherdef(int & t) {
    cout << "lvalue\n";
}
void otherdef(const int & t) {
    cout << "rvalue\n";
}

//实现完美转发的函数模板
template <typename T>
void function(T&& t) {
    otherdef(forward<T>(t));
}

int main()
{
    function(5);
    int  x = 1;
    function(x);
    return 0;
}
```



## 成员初始化列表

- 好处
  - 更高效：少了一次调用默认构造函数的过程。
  - 有些场合必须要用初始化列表：
    1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
    2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
    3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化



## 面向对象

- 面向对象三大特征 —— 封装、继承、多态

  ![image-20210602164243763](C:\Users\ln\OneDrive\校招准备\C++\Pic\image-20210602164243763-1622623365912.png)

### 封装

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。

- `public` 成员：可以被任意实体访问
- `protected` 成员：只允许被子类及本类的成员函数访问
- `private` 成员：只允许被本类的成员函数、友元类或友元函数访问

### 继承

- 基类（父类）——> 派生类（子类）

### 多态

- 多态是以封装和继承为基础的。
- C++ 多态分类及实现：
  1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
  2. 子类型多态（Subtype Polymorphism，运行期）：虚函数
  3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
  4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

#### 静态多态（编译期/早绑定）

函数重载

```cpp
class A
{
public:
    void do(int a);
    void do(int a, int b);
};
```

#### 动态多态（运行期/晚绑定）

- 虚函数：用 virtual 修饰成员函数，使其成为虚函数
- 动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定

**注意：**

- 可以将派生类的对象赋值给基类的指针或引用，反之不可
- 普通函数（非类成员函数）不能是虚函数
- 静态函数（static）不能是虚函数
- 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
- 内联函数不能是表现多态性时的虚函数



## 虚析构函数

- 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。

```cpp
class Shape
{
public:
    Shape();                    // 构造函数不能是虚函数
    virtual double calcArea();
    virtual ~Shape();           // 虚析构函数
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    shape1->calcArea();    
    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
    shape1 = NULL;
    return 0；
}
```



## 纯虚函数

- 纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。

```cpp
virtual int A() = 0;
```



## 虚函数与纯虚函数

- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。



## 虚函数指针、虚函数表

- 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。

- 虚函数表：在程序只读数据段（`.rodata section`），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。

  **重点：[虚函数实现机制及使用C实现虚函数](https://blog.twofei.com/496/)**

- **同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void\*\*类型)指向该虚函数表.**

  ![image-20210602171304371](C:\Users\ln\OneDrive\校招准备\C++\Pic\image-20210602171304371.png)

  - 该虚函数表是编译器在**编译时期**为我们创建好的, 只存在一份
  - 定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表



## 虚继承

- 虚继承用于解决多继承条件下的 **菱形继承问题（浪费存储空间、存在二义性）**
- 底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）
- 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。



## 虚继承、虚函数

- 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
- 不同之处：
  - 虚继承
    - 虚基类依旧存在继承类中，只占用存储空间
    - 虚基类表存储的是虚基类相对直接继承类的偏移
  - 虚函数
    - 虚函数不占用存储空间
    - 虚函数表存储的是虚函数地址



## 模板类、成员模板、虚函数

- 模板类中可以使用虚函数
- 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数



## new、delete

1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。



## placement new

- 定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。

  ```cpp
  new (place_address) type
  new (place_address) type (initializers)
  new (place_address) type [size]
  new (place_address) type [size] { braced initializer list }
  ```

  - `place_address` 是个指针
  - `initializers` 提供一个（可能为空的）以逗号分隔的初始值列表



## 如何定义一个只能在堆上（栈上）生成对象的类？

[如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)

#### 只能在堆上

- 方法：将析构函数设置为私有

- 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，**编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性**。若析构函数不可访问，则不能在栈上创建对象。

#### 只能在栈上

- 方法：将 new 和 delete 重载为私有

- 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。



## 智能指针

C++11中

1. shared_ptr

   - 多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。

2. unique_ptr

   - 是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

   - unique_ptr 用于取代 auto_ptr

3. weak_ptr

   - `weak_ptr`本身设计的很简单，就是为了辅助`shared_ptr`的，它本身不能直接定义指向原始指针的对象，只能指向`shared_ptr`对象，同时也不能将weak_ptr对象直接赋值给`shared_ptr`类型的变量，**最重要的一点是赋值给它不会增加引用计数**

   - weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。
   - **可打破环状引用**（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

4. auto_ptr（被 C++11 弃用）



## 强制类型转换运算符

### static

- 用于非多态类型的转换
- 不执行运行时类型检查（转换安全性不如 dynamic_cast）
- 通常用于转换数值数据类型（如 float -> int）
- 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）



### dynamic_cast

- 用于多态类型的转换
- 执行行运行时类型检查
- 只适用于指针或引用
- 对不明确的指针的转换将失败（返回 nullptr），但不引发异常
- 可以在整个类层次结构中移动指针，包括向上转换、向下转换



### const_cast

- 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）



### reinterpret_cast

- 用于位的简单重新解释
- 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。
- 允许将任何指针转换为任何其他指针类型（如 `char*` 到 `int*` 或 `One_class*` 到 `Unrelated_class*` 之类的转换，但其本身并不安全）
- 也允许将任何整数类型转换为任何指针类型以及反向转换。
- reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。
- reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。



### bad_cast

- 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。



## 运行时类型信息 (RTTI)

#### dynamic_cast

- 用于多态类型的转换

#### typeid

- typeid 运算符允许在运行时确定对象的类型
- type_id 返回一个 type_info 对象的引用
- 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数
- 只能获取对象的实际类型

#### type_info

- type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。
- 头文件：`typeinfo`



## lambda表达式原理

### lambda表达式结构

```cpp
[捕获列表] (形参列表) mutable 异常列表-> 返回类型
{
    函数体
}
```

### 编译原理实现	

编译器实现lambda表达式可分为以下几个步骤：

1. 创建**lambda类**，实现构造函数，使用lambda表达式的函数体重载operator()（所以lambda表达式也叫做 `匿名函数对象`）
2. 创建lambda对象
3. 通过对象调用operator()

### lambda匿名类与lambda表达式的对应关系

1. lambda 表达式中的**捕获列表**，对应 lambda 类中的**private成员**
2. lambda 表达式中的**形参列表**，对应 lambda 类成员函数 **operator() 的形参列表**
3. lambda 表达式中的 **mutable**，对应 lambda 类成员函数 **operator() 的常属性 const**，即是否是 **常成员函数**
4. lambda 表达式中的**返回类型**，对应 lambda 类成员函数 **operator() 的返回类型**
5. lambda 表达式中的**函数体**，对应 lambda 类成员函数 **operator() 的函数体**

捕获方式对应的private成员类型：

1. 值捕获：private 成员 的类型与捕获变量的类型一致
2. 引用捕获：private 成员 的类型是捕获变量的引用类型

### 不捕获任何外部变量

如果 lambda 表达式不捕获任何外部变量，在特定的情况下，会有额外的代码生成。

其中，特定情况是指：有 **lambda_xxxx 类** 到 **函数指针** 的类型转换

lambda 表达式没有捕获任何外部变量，即 lambda_xxxx 类没有任何成员变量，在 operator() 中也就不会用到任何成员变量，也就是说，operator() 虽然是个成员函数，它却不依赖 this 就可以调用。

因为不依赖 this，所以 一个 lambda_xxxx 类的匿名对象与函数指针之间就存在转换的可能。

大致过程如下：

1. 在 lambda_xxxx 类中生成一个**静态函数**，静态函数的函数签名**与 operator() 一致**，在这个静态函数中，通过一个**空指针**去调用该类的 operator()
2. 在 lambda_xxxx 重载与函数指针的类型转换操作符，在这个函数中，返回第 1 步中静态函数的地址。

编译器翻译代码如下：

```cpp
typedef int(_stdcall *Func)(int);

class lambda_xxxx 
{
private:
	//没有捕获任何外部变量，所有没有成员
public:
        /*...省略其他代码...*/
	int operator()(int i)
	{
		return i;
	}
	static int _stdcall lambda_invoker_stdcall(int i)
	{
		return ((lambda_xxxx *)nullptr)->operator()(i);
	}

	operator Func() const
	{
		return &lambda_invoker_stdcall;
	}
};

int Test(Func func)
{
	return func(1);
}
void LambdaDemo()
{
	auto lambda = lambda_xxxx ();
	Func func = lambda.operator Func();
	Test(func);
}
```

​	

## static变量

static变量放在类外初始化，并且**最好在CPP文件中初始化以防被多次include导致的重复初始化**

**类内的static变量只是声明，不能直接定义，应在类外进行定义，防止多个对象对static重复定义**

定义在类体外进行，而前面不加static，**以免与一般静态变量或对象相混淆。**

`static const int`可以在类里面初始化（只能是整型变量：int、bool等），**因为const对象是不允许改变的**



## 类中成员是引用

- **不能有默认构造函数，必须提供构造函数**
  - 凡是有引用类型的成员变量的类，不能有默认构造函数。默认构造函数没有对引用成员提供默认的初始化机制，也因此造成引用未初始化的编译错误。
- **构造函数的形参必须为引用类型**
- **初始化必须在成员初始化链表内完成**
  - 不能直接在构造函数里初始化，必须用到初始化列表，且形参也必须是引用类型。



## 在main函数之前或之后运行一段程序

- main函数之前

  - 程序在执行时会调用各种各样的运行时库函数，因此执行前main函数必须要初始化好运行时库，还要完成一些全局变量以及C内存分配等初始化工作，在C++里，还要执行全局类对象的构造函数。最后才调用main函数。

  - 方法一：C、C++方法（***利用全局变量的构造函数初始化的时候可以被执行的特点来进行。***）

    ```CPP
    #include<iostream>
    using namespace std;
    
    class A
    {
    public:
    	A(){cout<<"A"<<endl;}//构造函数
    };
    A a;//声明一个全局变量
    
    int main()
    {
    	cout<<"main func"<<endl;
    	return 0;
    }
    ```

  - 方法二：C++方法（***全局变量的赋值函数，会在main之前执行。***）

    ```cpp
    #include<iostream>
    #include<stdio.h>
    using namespace std;
    
    int f()
    {
    	printf("before\n");
    	return 0;
    }
    int a = f();
    int main()
    {
    	printf("main\n");
    	return 0;
    }
    ```

  - 方法三：***如果是GNUC的编译器，可在要执行的方法前加\_\_attribute__((constructor))***

    ```cpp
    #include<stdio.h>
    
    __attribute__((constructor)) void func()
    {
    	printf("hello world\n");
    }
    
    int main()
    {
    	printf("main\n");//从运行结果来看，并没有执行main函数
    }
    ```

- main函数之后

  - 方法一：C、C++方法（***利用析构函数的特点***）

    ```CPP
    #include<iostream>
    using namespace std;
    
    class A
    {
    public:
    	~A()
    	{
    		cout<<"~A"<<endl;
    	}
    };
    
    A a;
    int main()
    {
    	cout<<"main"<<endl;
    	return 0;
    }
    ```

  - 方法二：***如果是GNUC的编译器，可在你要执行的方法前加\_\_attribute__((destructor))***

    ```CPP
    #include<stdio.h>
    
    void func()
    {
    	printf("hello world\n");
    	return 0;
    }
    
    __attribute__((destructor)) void after()
    {
    	printf("after\n");
    }
    
    int main()
    {
    	printf("main\n");
    }
    ```

- constructor参数让系统执行main()函数之前调用函数（被\_\_arrribute__((constructor))修饰的函数）。同理，destructor让系统在main()函数调用了exit()之后，调用我们的函数，带有这些修饰属性的函数，对于我们初始化一些在程序中使用的数据非常有用。



## const和constexpr的区别

- constexpr是C++11中新增的关键字，其语义是 **“常量表达式”**，也就是在 **编译期可求值的表达式**。最基础的常量表达式就是字面值或全局变量/函数的地址或sizeof等关键字返回的结果，而其它常量表达式都是由基础表达式通过各种确定的运算得到的。
- constexpr所修饰的变量一定是编译期可求值的，所修饰的函数在其所有参数都是constexpr时，一定会返回constexpr。
- constexpr还能用于**修饰类的构造函数**，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。
- constexpr的好处
  - 是一种很强的约束，更好地保证程序的正确语义不被破坏。
  - 编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。
  - 相比宏来说，没有额外的开销，但更安全可靠。
- **const修饰对象无法修改，constexpr更侧重于修饰对象编译期确定且无法修改。**



